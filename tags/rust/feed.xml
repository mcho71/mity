<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>
    Rust on 
    Mcho
    </title>
    <link>https://mcho.dev/tags/rust/</link>
    <description>Recent content in Rust
    on Mcho</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    
    
    <copyright>&amp;copy; mcho 2019</copyright>
    <lastBuildDate>Tue, 12 Nov 2019 15:23:06 +0900</lastBuildDate>
    
    
        <atom:link href="https://mcho.dev/tags/rust/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Rustで始めるOpenGLをやっている</title>
      <link>https://mcho.dev/notes/rust%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8Bopengl/</link>
      <pubDate>Tue, 12 Nov 2019 15:23:06 +0900</pubDate>
      
      <guid>https://mcho.dev/notes/rust%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8Bopengl/</guid>
      <description><![CDATA[これはなに [DL 版] Rust ではじめる OpenGL - toyamaguchi - BOOTHをなぞった際のメモです。 目次を読む ライブラリごとに章が区切られている 環境準備 SDL OpenGL Dear ImGui 3D オブジェクト テクスチャ ほとんど触れたことがないな、とりあえず上からや]]></description>
      <content:encoded><![CDATA[<h2 id="これはなに">これはなに</h2>
<p><a href="https://toyamaguchi.booth.pm/items/1557536" target="_blank" rel="nofollow noopener">[DL 版] Rust ではじめる OpenGL - toyamaguchi - BOOTH</a>をなぞった際のメモです。</p>
<h2 id="目次を読む">目次を読む</h2>
<p>ライブラリごとに章が区切られている</p>
<ol>
<li>環境準備</li>
<li>SDL</li>
<li>OpenGL</li>
<li>Dear ImGui</li>
<li>3D オブジェクト</li>
<li>テクスチャ</li>
</ol>
<p>ほとんど触れたことがないな、とりあえず上からやっていこう
ソースコード →<a href="https://github.com/toyamaguchi/start_opengl_in_rust" target="_blank" rel="nofollow noopener">toyamaguchi/start_opengl_in_rust</a></p>
<h2 id="環境">環境</h2>
<ul>
<li><a href="https://www.rust-lang.org/" target="_blank" rel="nofollow noopener">Rust Programming Language</a>に従って Rust をインストール
<ul>
<li>version は 1.39 だった</li>
<li>crate は<a href="https://crates.io/" target="_blank" rel="nofollow noopener">crates.io: Rust Package Registry</a>で検索できる</li>
<li>VSCode の rls、rustup のパスを通してやる必要があった。<code>&quot;rust-client.rustupPath&quot;: &quot;~/.cargo/bin/rustup&quot;</code></li>
</ul>
</li>
</ul>
<h2 id="sdl">SDL</h2>
<p>SDL は、グラフィックやサウンドの機能を持ったマルチメディアライブラリ。
<a href="https://ja.wikipedia.org/wiki/SDL" target="_blank" rel="nofollow noopener">SDL - Wikipedia</a><br>
これだけでも十分な機能を持つゲームを作成可能らしい</p>
<p>Rust からの利用は<code>crate「sdl2」</code>を利用する。<a href="https://github.com/Rust-SDL2/rust-sdl2" target="_blank" rel="nofollow noopener">Rust-SDL2/rust-sdl2: SDL2 bindings for Rust</a><br>
<code>sd12</code>は C 言語で書かれたライブラリを間接的に利用するラッパーのため SDL のインストールも必要。</p>
<p>SDL を使ってソフトに必要な構造を作って OpenGL で描画をしていく。基本的な構造とは、ウィンドウやメインループ、イベント処理のような部分。</p>
<h3 id="準備">準備</h3>
<ul>
<li><a href="https://github.com/Rust-SDL2/rust-sdl2" target="_blank" rel="nofollow noopener">Rust-SDL2/rust-sdl2: SDL2 bindings for Rust</a> の手順通り SDL をインストール</li>
<li><code>cargo.toml</code>に<code>sd12</code>を追加</li>
</ul>
<h3 id="作成">作成</h3>
<p><code>sdl2</code>の crates.io ページを見る。</p>
<h2 id="opengl">OpenGL</h2>
<p>SDL のウィンドウに描画していく</p>
<h3 id="準備-1">準備</h3>
<p><code>cargo.toml</code>に<code>gl</code>(OpenGL の API を利用可能に),<code>cgmath</code>(CG 用の数学関連機能),<code>c_str_macro</code>(C 言語とコンパチビリティんのある文字列型を生成できる<code>c_str!</code>マクロが使えるようになる)を追加</p>
<h3 id="作成-1">作成</h3>
<p>HelloWorld は難しいらしいので三角形を描画する</p>
<p>シェーダーという言葉が出てきた</p>
<p>写経辛いのでコピペに切り替えていく</p>
<p>OpenGL3.1 を使う、このバージョンは丁度 API が一新されたバージョンで、<code>Core</code>(新しい API のみ)と<code>Compability</code>(古い API もサポート)パッケージがある。今回は<code>Core</code></p>
<p>描画はシェーダと呼ばれる描画プログラムを通してデータを送る<br>
シェーダなしのサンプルコードは古い可能性があるので注意<br>
呼び名は<br>
あり: Programmable Pipeline<br>
なし: Fixed Function Pipeline<br>
などというらしい</p>
<p>シェーダは実行時にソースコードをコンパイルして使えるプログラムなのでこういった名称になってる</p>
<p>今回具体的には Vertex シェーダと Fragment シェーダを使った</p>
<h4 id="vertex-シェーダ">Vertex シェーダ</h4>
<p>Vertex はそもそも頂点のこと、辺と辺を結ぶ点。3D 空間内の頂点座標を画面上の座標にするまでに必要な計算をこのシェーダでやってる</p>
<p>描画したい頂点が、3D 空間の中でどの位置にあるのかを表すモデル行列<br>
カメラの一を考慮したビュー行列<br>
カメラから見た 3D 空間をどのように画面に描画するかを表す射影行列<br>
3 つの行列をかけ合わせて最終的な画面上の座標になる</p>
<h4 id="fragment-シェーダ">Fragment シェーダ</h4>
<p>色を計算するシェーダ、Vertex シェーダから座標を得てテクスチャの中から適切な位置の色情報を計算して描画につかう</p>
<p>どちらも GLSL を使って実装する。<br>
GLSL(OpenGL Shading Language)はシェーダ専用の言語、GPU や前段のシェーダからの情報、扱える変数に独特のルールがある。<br>
GPU での動作なので並列計算できる、画面上に多くの 3D オブジェクトを描画したいならシェーダを使って効果的に描画する必要がある。</p>
<p>GLSL のバージョンは 3.3</p>
<p>VBO(Vertex Buffer Object)は CPU から GPU に情報を渡すための入れ物、頂点データだったり色情報だったり<br>
VAO(Vertex Array Object)は VBO をどのようなまとまりで使うのかを設定するもの</p>
<p>WebGL の話ものってそう</p>
<p>サンプルコードが動かない → 動いた、sample リポジトリの rsc フォルダを追加すればよかっただけだった。章の最後に書いてあった。</p>
<pre tabindex="0"><code class="language-log" data-lang="log">RUST_BACKTRACE=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
     Running `target/debug/rust-opengl`
OK: init OpenGL: version=3.1
thread 'main' panicked at 'failed to open file: rsc/shader/shader.vs', src/shader.rs:28:33
stack backtrace:
   0: backtrace::backtrace::libunwind::trace
             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/backtrace/libunwind.rs:88
   1: backtrace::backtrace::trace_unsynchronized
             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.37/src/backtrace/mod.rs:66
   2: std::sys_common::backtrace::_print_fmt
             at src/libstd/sys_common/backtrace.rs:76
   3: &lt;std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display&gt;::fmt
             at src/libstd/sys_common/backtrace.rs:60
   4: core::fmt::write
             at src/libcore/fmt/mod.rs:1030
   5: std::io::Write::write_fmt
             at src/libstd/io/mod.rs:1412
   6: std::sys_common::backtrace::_print
             at src/libstd/sys_common/backtrace.rs:64
   7: std::sys_common::backtrace::print
             at src/libstd/sys_common/backtrace.rs:49
   8: std::panicking::default_hook::{{closure}}
             at src/libstd/panicking.rs:196
   9: std::panicking::default_hook
             at src/libstd/panicking.rs:210
  10: std::panicking::rust_panic_with_hook
             at src/libstd/panicking.rs:473
  11: std::panicking::continue_panic_fmt
             at src/libstd/panicking.rs:380
  12: std::thread::local::fast::Key&lt;T&gt;::try_initialize
  13: rust_opengl::shader::Shader::new::{{closure}}
             at src/shader.rs:28
  14: core::result::Result&lt;T,E&gt;::unwrap_or_else
             at /rustc/4560ea788cb760f0a34127156c78e2552949f734/src/libcore/result.rs:818
  15: rust_opengl::shader::Shader::new
             at src/shader.rs:27
  16: rust_opengl::main
             at src/main.rs:52
  17: std::rt::lang_start::{{closure}}
             at /rustc/4560ea788cb760f0a34127156c78e2552949f734/src/libstd/rt.rs:64
  18: std::rt::lang_start_internal::{{closure}}
             at src/libstd/rt.rs:49
  19: std::panicking::try::do_call
             at src/libstd/panicking.rs:292
  20: __rust_maybe_catch_panic
             at src/libpanic_unwind/lib.rs:80
  21: std::panicking::try
             at src/libstd/panicking.rs:271
  22: std::panic::catch_unwind
             at src/libstd/panic.rs:394
  23: std::rt::lang_start_internal
             at src/libstd/rt.rs:48
  24: std::rt::lang_start
             at /rustc/4560ea788cb760f0a34127156c78e2552949f734/src/libstd/rt.rs:64
  25: rust_opengl::main
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre><p>できた。



<picture>
  <img src="/img/2019-11-12-18-08-05.png" alt="" decoding="async" loading="lazy">
</picture>
</p>
<p>頂点情報はこういう感じで書いていた</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="c1">// set buffer
</span><span class="c1"></span><span class="w">    </span><span class="cp">#[rustfmt::skip]</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">buffer_array</span>: <span class="p">[</span><span class="kt">f32</span><span class="p">;</span><span class="w"> </span><span class="n">BUF_LEN</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">];</span><span class="w">
</span></code></pre></div><h2 id="dear-imgui">Dear ImGui</h2>
<p><a href="https://github.com/ocornut/imgui" target="_blank" rel="nofollow noopener">ocornut/imgui</a></p>
<p>OpenGL に様々な GUI を追加できるライブラリ</p>
<p>これを使って SDL2 のウィンドウに新たにウィンドウを追加する。</p>
<p>出た</p>
<p>


<picture>
  <img src="/img/2019-12-17-15-49-08.png" alt="" decoding="async" loading="lazy">
</picture>
</p>
<p>


<picture>
  <img src="/img/2019-12-17-15-59-28.png" alt="" decoding="async" loading="lazy">
</picture>
</p>
<h3 id="効果的な使い方">効果的な使い方</h3>
<p>パラメータの微調節を行えるように、ここの値をスライダーで調節できるようにすると良いらしい
FPS を表示も</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>